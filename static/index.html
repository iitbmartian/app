<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ROS2 3D Visualizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 100%);
            color: #ffffff;
            overflow: hidden;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #canvas-container {
            width: 100%;
            height: 100%;
            position: relative;
        }

        /* Control Panel */
        #control-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
            min-width: 280px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            z-index: 100;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group h3 {
            font-size: 14px;
            margin-bottom: 8px;
            color: #64ffda;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .control-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        .control-row label {
            font-size: 12px;
            color: #b0b0b0;
        }

        .toggle-btn {
            background: linear-gradient(135deg, #2196F3, #21CBF3);
            border: none;
            border-radius: 6px;
            color: white;
            padding: 6px 12px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .toggle-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(33, 150, 243, 0.4);
        }

        .toggle-btn.inactive {
            background: linear-gradient(135deg, #424242, #616161);
        }

        /* Status Panel */
        #status-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 15px;
            min-width: 300px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            font-family: 'Courier New', monospace;
            font-size: 12px;
            z-index: 100;
        }

        .status-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            padding: 3px 0;
        }

        .status-label {
            color: #b0b0b0;
        }

        .status-value {
            color: #64ffda;
            font-weight: bold;
        }

        .connection-status {
            padding: 8px 12px;
            border-radius: 6px;
            font-weight: bold;
            text-align: center;
            margin-bottom: 10px;
        }

        .connected {
            background: linear-gradient(135deg, #4CAF50, #8BC34A);
        }

        .disconnected {
            background: linear-gradient(135deg, #f44336, #ff5722);
        }

        /* Loading Animation */
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 200;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(100, 255, 218, 0.3);
            border-top: 3px solid #64ffda;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Responsive */
        @media (max-width: 768px) {
            #control-panel {
                top: 10px;
                right: 10px;
                min-width: 240px;
                padding: 15px;
            }
            
            #status-panel {
                bottom: 10px;
                left: 10px;
                min-width: 250px;
            }
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="canvas-container"></div>
        
        <!-- Loading Screen -->
        <div id="loading" class="loading">
            <div class="spinner"></div>
            <div>Connecting to ROS2 Bridge...</div>
        </div>

        <!-- Control Panel -->
        <div id="control-panel">
            <div class="control-group">
                <h3>Topics</h3>
                <div class="control-row">
                    <label>Map</label>
                    <button class="toggle-btn" id="toggle-map">ON</button>
                </div>
                <div class="control-row">
                    <label>Local Costmap</label>
                    <button class="toggle-btn" id="toggle-costmap">ON</button>
                </div>
                <div class="control-row">
                    <label>Point Cloud</label>
                    <button class="toggle-btn" id="toggle-pointcloud">ON</button>
                </div>
                <div class="control-row">
                    <label>Global Path</label>
                    <button class="toggle-btn" id="toggle-globalpath">ON</button>
                </div>
                <div class="control-row">
                    <label>Local Path</label>
                    <button class="toggle-btn" id="toggle-localpath">ON</button>
                </div>
                <div class="control-row">
                    <label>Markers</label>
                    <button class="toggle-btn" id="toggle-markers">ON</button>
                </div>
                <div class="control-row">
                    <label>Robot Pose</label>
                    <button class="toggle-btn" id="toggle-robot">ON</button>
                </div>
            </div>

            <div class="control-group">
                <h3>View</h3>
                <div class="control-row">
                    <button class="toggle-btn" id="reset-camera">Reset View</button>
                </div>
                <div class="control-row">
                    <button class="toggle-btn" id="follow-robot">Follow Robot</button>
                </div>
            </div>
        </div>

        <!-- Status Panel -->
        <div id="status-panel">
            <div id="connection-status" class="connection-status disconnected">DISCONNECTED</div>
            <div class="status-item">
                <span class="status-label">FPS:</span>
                <span class="status-value" id="fps-counter">0</span>
            </div>
            <div class="status-item">
                <span class="status-label">Points:</span>
                <span class="status-value" id="point-count">0</span>
            </div>
            <div class="status-item">
                <span class="status-label">Map Size:</span>
                <span class="status-value" id="map-size">0x0</span>
            </div>
            <div class="status-item">
                <span class="status-label">Path Points:</span>
                <span class="status-value" id="path-points">0</span>
            </div>
            <div class="status-item">
                <span class="status-label">Markers:</span>
                <span class="status-value" id="marker-count">0</span>
            </div>
            <div class="status-item">
                <span class="status-label">Last Update:</span>
                <span class="status-value" id="last-update">Never</span>
            </div>
        </div>
    </div>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        class ROS3DVisualizer {
            constructor() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                
                // WebSocket connection
                this.ws = null;
                this.isConnected = false;
                this.reconnectAttempts = 0;
                this.maxReconnectAttempts = 5;
                
                // Scene objects
                this.mapMesh = null;
                this.costmapMesh = null;
                this.pointCloudMesh = null;
                this.globalPathMesh = null;
                this.localPathMesh = null;
                this.robotMesh = null;
                this.markerObjects = new Map();
                
                // Layer visibility
                this.layers = {
                    map: true,
                    costmap: true,
                    pointcloud: true,
                    globalpath: true,
                    localpath: true,
                    markers: true,
                    robot: true
                };
                
                // Camera controls
                this.controls = null;
                this.followRobot = false;
                this.robotPosition = new THREE.Vector3();
                
                // Performance tracking
                this.frameCount = 0;
                this.lastTime = performance.now();
                this.fps = 0;
                
                this.init();
                this.setupEventListeners();
                this.connect();
                this.animate();
            }

            rosToThreePosition(pos) {
                const v = new THREE.Vector3(pos.x, pos.y, pos.z);
                v.applyAxisAngle(new THREE.Vector3(1,0,0), -Math.PI/2);
                return v;
            }
            rosToThreeQuaternion(ori) {
                const q = new THREE.Quaternion(ori.x, ori.y, ori.z, ori.w);
                const rosToThree = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1,0,0), -Math.PI/2);
                q.multiply(rosToThree);
                return q;
            }
            
            init() {
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(0x0f0f23, 1);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.getElementById('canvas-container').appendChild(this.renderer.domElement);

                this.camera.position.set(10, 10, 10);
                this.camera.lookAt(0, 0, 0);

                this.setupCameraControls();
                this.setupScene();
                document.getElementById('loading').style.display = 'block';
            }

            setupScene() {
                this.scene.add(new THREE.AmbientLight(0x404040, 0.6));
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(10, 10, 5);
                this.scene.add(directionalLight);

                const gridHelper = new THREE.GridHelper(50, 50, 0x444444, 0x222222);
                this.scene.add(gridHelper);

                this.scene.add(new THREE.AxesHelper(2));
            }
            
            setupCameraControls() {
                // Simple mouse controls for camera
                let isDragging = false;
                let previousMousePosition = { x: 0, y: 0 };
                let cameraDistance = 20;
                let cameraAngleY = 0;
                let cameraAngleX = 0.3;
                
                const updateCameraPosition = () => {
                    const target = this.followRobot ? this.robotPosition : new THREE.Vector3(0, 0, 0);
                                    
                    this.camera.position.x = target.x + cameraDistance * Math.cos(cameraAngleY) * Math.cos(cameraAngleX);
                    this.camera.position.y = target.y + cameraDistance * Math.sin(cameraAngleY) * Math.cos(cameraAngleX);
                    this.camera.position.z = target.z + cameraDistance * Math.sin(cameraAngleX);                    
                    this.camera.lookAt(target);
                };
                
                this.renderer.domElement.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                });
                
                this.renderer.domElement.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    
                    const deltaX = e.clientX - previousMousePosition.x;
                    const deltaY = e.clientY - previousMousePosition.y;
                    
                    cameraAngleY += deltaX * 0.01;
                    cameraAngleX = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, cameraAngleX - deltaY * 0.01));
                    
                    updateCameraPosition();
                    
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                });
                
                this.renderer.domElement.addEventListener('mouseup', () => {
                    isDragging = false;
                });
                
                this.renderer.domElement.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    cameraDistance = Math.max(2, Math.min(100, cameraDistance + e.deltaY * 0.01));
                    updateCameraPosition();
                });
                
                this.updateCameraPosition = updateCameraPosition;
                updateCameraPosition();
            }
            
            setupEventListeners() {
                // Window resize
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
                
                // Layer toggles
                Object.keys(this.layers).forEach(layer => {
                    const button = document.getElementById(`toggle-${layer}`);
                    if (button) {
                        button.addEventListener('click', () => this.toggleLayer(layer));
                    }
                });
                
                // Camera controls
                document.getElementById('reset-camera').addEventListener('click', () => {
                    this.followRobot = false;
                    this.camera.position.set(10, 10, 10);
                    this.camera.lookAt(0, 0, 0);
                });
                
                document.getElementById('follow-robot').addEventListener('click', () => {
                    this.followRobot = !this.followRobot;
                    const button = document.getElementById('follow-robot');
                    button.textContent = this.followRobot ? 'Unfollow Robot' : 'Follow Robot';
                    button.classList.toggle('inactive', !this.followRobot);
                });
            }
            
            toggleLayer(layerName) {
                this.layers[layerName] = !this.layers[layerName];
                const button = document.getElementById(`toggle-${layerName}`);
                button.textContent = this.layers[layerName] ? 'ON' : 'OFF';
                button.classList.toggle('inactive', !this.layers[layerName]);
                
                // Update visibility
                this.updateLayerVisibility();
            }
            
            updateLayerVisibility() {
                if (this.mapMesh) this.mapMesh.visible = this.layers.map;
                if (this.costmapMesh) this.costmapMesh.visible = this.layers.costmap;
                if (this.pointCloudMesh) this.pointCloudMesh.visible = this.layers.pointcloud;
                if (this.globalPathMesh) this.globalPathMesh.visible = this.layers.globalpath;
                if (this.localPathMesh) this.localPathMesh.visible = this.layers.localpath;
                if (this.robotMesh) this.robotMesh.visible = this.layers.robot;
                
                this.markerObjects.forEach(marker => {
                    marker.visible = this.layers.markers;
                });
            }
            
            connect() {
                const wsUrl = `ws://${window.location.hostname}:8000/ws`;
                console.log('Connecting to:', wsUrl);
                
                this.ws = new WebSocket(wsUrl);
                
                this.ws.onopen = () => {
                    console.log('WebSocket connected');
                    this.isConnected = true;
                    this.reconnectAttempts = 0;
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('connection-status').textContent = 'CONNECTED';
                    document.getElementById('connection-status').className = 'connection-status connected';
                };
                
                this.ws.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        this.processRosData(data);
                        document.getElementById('last-update').textContent = new Date().toLocaleTimeString();
                    } catch (error) {
                        console.error('Error processing WebSocket message:', error);
                    }
                };
                
                this.ws.onclose = () => {
                    console.log('WebSocket disconnected');
                    this.isConnected = false;
                    document.getElementById('connection-status').textContent = 'DISCONNECTED';
                    document.getElementById('connection-status').className = 'connection-status disconnected';
                    
                    if (this.reconnectAttempts < this.maxReconnectAttempts) {
                        setTimeout(() => {
                            this.reconnectAttempts++;
                            console.log(`Reconnection attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts}`);
                            this.connect();
                        }, 2000 * this.reconnectAttempts);
                    }
                };
                
                this.ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                };
            }
            
            processRosData(data) {
                if (data.map) this.updateMap(data.map);
                if (data.local_costmap) this.updateCostmap(data.local_costmap);
                if (data.point_cloud) this.updatePointCloud(data.point_cloud);
                if (data.global_path) this.updateGlobalPath(data.global_path);
                if (data.local_path) this.updateLocalPath(data.local_path);
                if (data.markers) this.updateMarkers(data.markers);
                if (data.robot_pose) this.updateRobotPose(data.robot_pose);
            }
            
           updateMap(mapData) {
                // Remove existing map
                if (this.mapMesh) {
                    this.scene.remove(this.mapMesh);
                    this.mapMesh.geometry.dispose();
                    this.mapMesh.material.dispose();
                }
                
                const { width, height, resolution, origin, data } = mapData;
                
                // Create texture for the map - proper plane rendering
                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');
                
                // Create image data
                const imageData = ctx.createImageData(width, height);
                
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const index = y * width + x;
                        const value = data[index];
                        const pixelIndex = (y * width + x) * 4;
                        
                        if (value === -1) {
                            // Unknown space - gray
                            imageData.data[pixelIndex] = 128;     // R
                            imageData.data[pixelIndex + 1] = 128; // G
                            imageData.data[pixelIndex + 2] = 128; // B
                            imageData.data[pixelIndex + 3] = 255; // A
                        } else if (value > 50) {
                            // Occupied space - black
                            imageData.data[pixelIndex] = 0;       // R
                            imageData.data[pixelIndex + 1] = 0;   // G
                            imageData.data[pixelIndex + 2] = 0;   // B
                            imageData.data[pixelIndex + 3] = 255; // A
                        } else {
                            // Free space - white
                            imageData.data[pixelIndex] = 255;     // R
                            imageData.data[pixelIndex + 1] = 255; // G
                            imageData.data[pixelIndex + 2] = 255; // B
                            imageData.data[pixelIndex + 3] = 255; // A
                        }
                    }
                }
                
                ctx.putImageData(imageData, 0, 0);
                
                // Create texture from canvas
                const texture = new THREE.CanvasTexture(canvas);
                texture.flipY = false; // Important for correct orientation
                
                // Create plane geometry - positioned correctly in ROS2 coordinate system
                const geometry = new THREE.PlaneGeometry(width * resolution, height * resolution);
                const material = new THREE.MeshLambertMaterial({ 
                    map: texture, 
                    transparent: true,
                    opacity: 0.8
                });
                
                this.mapMesh = new THREE.Mesh(geometry, material);
                
                // Position the map correctly using origin
                this.mapMesh.position.set(
                    origin.x + (width * resolution) / 2,
                    origin.y + (height * resolution) / 2,
                    0.001  // Slightly above ground plane
                );
                
                // Rotate to align with ROS2 coordinate system (map is in XY plane)
                this.mapMesh.rotation.x = -Math.PI / 2;
                
                this.mapMesh.visible = this.layers.map;
                this.scene.add(this.mapMesh);
                
                // Update status
                document.getElementById('map-size').textContent = `${width}x${height}`;
            }
            
            updateCostmap(costmapData) {
                // Remove existing costmap
                if (this.costmapMesh) {
                    this.scene.remove(this.costmapMesh);
                    this.costmapMesh.geometry.dispose();
                    this.costmapMesh.material.dispose();
                }
                
                const { width, height, resolution, origin, data } = costmapData;
                
                // Create texture for the costmap
                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');
                
                // Create image data for costmap
                const imageData = ctx.createImageData(width, height);
                
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const index = y * width + x;
                        const value = data[index];
                        const pixelIndex = (y * width + x) * 4;
                        
                        if (value > 0 && value < 255) {
                            // Cost cell - color from green to red based on cost
                            const intensity = value / 254.0;
                            imageData.data[pixelIndex] = Math.floor(255 * intensity);      // R
                            imageData.data[pixelIndex + 1] = Math.floor(255 * (1 - intensity)); // G
                            imageData.data[pixelIndex + 2] = 0;                           // B
                            imageData.data[pixelIndex + 3] = Math.floor(180 * intensity); // A (transparency based on cost)
                        } else {
                            // Transparent for free space
                            imageData.data[pixelIndex] = 0;
                            imageData.data[pixelIndex + 1] = 0;
                            imageData.data[pixelIndex + 2] = 0;
                            imageData.data[pixelIndex + 3] = 0;
                        }
                    }
                }
                
                ctx.putImageData(imageData, 0, 0);
                
                // Create texture from canvas
                const texture = new THREE.CanvasTexture(canvas);
                texture.flipY = false;
                
                // Create plane geometry for costmap
                const geometry = new THREE.PlaneGeometry(width * resolution, height * resolution);
                const material = new THREE.MeshLambertMaterial({ 
                    map: texture, 
                    transparent: true,
                    opacity: 0.7
                });
                
                this.costmapMesh = new THREE.Mesh(geometry, material);
                
                // Position the costmap slightly above the map
                this.costmapMesh.position.set(
                    origin.x + (width * resolution) / 2,
                    origin.y + (height * resolution) / 2,
                    0.002  // Slightly above map
                );
                
                // Rotate to align with ROS2 coordinate system
                this.costmapMesh.rotation.x = -Math.PI / 2;
                
                this.costmapMesh.visible = this.layers.costmap;
                this.scene.add(this.costmapMesh);
            }
            
            updatePointCloud(cloudData) {
                if (this.pointCloudMesh) {
                    this.scene.remove(this.pointCloudMesh);
                    this.pointCloudMesh.geometry.dispose();
                    this.pointCloudMesh.material.dispose();
                }
                const { points, colors } = cloudData;
                if (points.length === 0) return;

                // transform each point
                const transformed = [];
                for (let i = 0; i < points.length; i += 3) {
                    const p = this.rosToThreePosition({x:points[i], y:points[i+1], z:points[i+2]});
                    transformed.push(p.x, p.y, p.z);
                }

                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(transformed, 3));
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

                const material = new THREE.PointsMaterial({ size: 0.05, vertexColors: true, sizeAttenuation: true });
                this.pointCloudMesh = new THREE.Points(geometry, material);
                this.pointCloudMesh.visible = this.layers.pointcloud;
                this.scene.add(this.pointCloudMesh);

                document.getElementById('point-count').textContent = Math.floor(points.length / 3);
            }
            
            updateGlobalPath(pathData) {
                if (this.globalPathMesh) { this.scene.remove(this.globalPathMesh); this.globalPathMesh.geometry.dispose(); this.globalPathMesh.material.dispose(); }
                if (pathData.poses.length < 2) return;
                const points = pathData.poses.map(pose => {
                    const p = this.rosToThreePosition(pose.position);
                    p.z += 0.1; return p;
                });
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                this.globalPathMesh = new THREE.Line(geometry, new THREE.LineBasicMaterial({ color: 0x00ff00, linewidth: 3 }));
                this.globalPathMesh.visible = this.layers.globalpath; this.scene.add(this.globalPathMesh);
                document.getElementById('path-points').textContent = pathData.poses.length;
            }
            
            updateLocalPath(pathData) {
                if (this.localPathMesh) { this.scene.remove(this.localPathMesh); this.localPathMesh.geometry.dispose(); this.localPathMesh.material.dispose(); }
                if (pathData.poses.length < 2) return;
                const points = pathData.poses.map(pose => {
                    const p = this.rosToThreePosition(pose.position);
                    p.z += 0.15; return p;
                });
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                this.localPathMesh = new THREE.Line(geometry, new THREE.LineBasicMaterial({ color: 0xffff00, linewidth: 2 }));
                this.localPathMesh.visible = this.layers.localpath; this.scene.add(this.localPathMesh);
            }

            
            updateMarkers(markersData) {
                // Clear existing markers
                this.markerObjects.forEach(marker => {
                    this.scene.remove(marker);
                    if (marker.geometry) marker.geometry.dispose();
                    if (marker.material) marker.material.dispose();
                });
                this.markerObjects.clear();
                
                markersData.markers.forEach(markerData => {
                    const marker = this.createMarker(markerData);
                    if (marker) {
                        marker.visible = this.layers.markers;
                        this.markerObjects.set(`${markerData.ns}_${markerData.id}`, marker);
                        this.scene.add(marker);
                    }
                });
                
                // Update status
                document.getElementById('marker-count').textContent = this.markerObjects.size;
            }
            
            createMarker(m) {
                let geometry;
                switch (m.type) {
                    case 1: geometry = new THREE.BoxGeometry(m.scale.x, m.scale.y, m.scale.z); break;
                    case 2: geometry = new THREE.SphereGeometry(m.scale.x/2,16,12); break;
                    case 3: geometry = new THREE.CylinderGeometry(m.scale.x/2, m.scale.x/2, m.scale.z, 16); break;
                    case 0: geometry = new THREE.ConeGeometry(m.scale.x/4, m.scale.z, 8); break;
                    default: geometry = new THREE.BoxGeometry(m.scale.x, m.scale.y, m.scale.z);
                }
                const material = new THREE.MeshLambertMaterial({ 
                    color:new THREE.Color(m.color.r,m.color.g,m.color.b), 
                    transparent:m.color.a<1.0, opacity:m.color.a 
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.copy(this.rosToThreePosition(m.position));
                mesh.quaternion.copy(this.rosToThreeQuaternion(m.orientation));
                return mesh;
            }
            
            updateRobotPose(p) {
                if (this.robotMesh) { this.scene.remove(this.robotMesh); this.robotMesh.geometry.dispose(); this.robotMesh.material.dispose(); }
                this.robotMesh = new THREE.Mesh(new THREE.ConeGeometry(0.2,0.4,8), new THREE.MeshLambertMaterial({ color:0xff0000 }));
                this.robotMesh.position.copy(this.rosToThreePosition(p.position).add(new THREE.Vector3(0,0,0.2)));
                this.robotMesh.quaternion.copy(this.rosToThreeQuaternion(p.orientation));
                this.robotMesh.visible = this.layers.robot; this.scene.add(this.robotMesh);
                this.robotPosition.copy(this.rosToThreePosition(p.position));
                if (this.followRobot && this.updateCameraPosition) this.updateCameraPosition();
            }
            
            addCube(positions, colors, x, y, z, size, color) {
                const halfSize = size / 2;
                
                // Define cube vertices
                const vertices = [
                    // Front face
                    x - halfSize, y - halfSize, z + halfSize,
                    x + halfSize, y - halfSize, z + halfSize,
                    x + halfSize, y + halfSize, z + halfSize,
                    x + halfSize, y + halfSize, z + halfSize,
                    x - halfSize, y + halfSize, z + halfSize,
                    x - halfSize, y - halfSize, z + halfSize,
                    
                    // Back face
                    x - halfSize, y - halfSize, z - halfSize,
                    x - halfSize, y + halfSize, z - halfSize,
                    x + halfSize, y + halfSize, z - halfSize,
                    x + halfSize, y + halfSize, z - halfSize,
                    x + halfSize, y - halfSize, z - halfSize,
                    x - halfSize, y - halfSize, z - halfSize,
                    
                    // Top face
                    x - halfSize, y + halfSize, z - halfSize,
                    x - halfSize, y + halfSize, z + halfSize,
                    x + halfSize, y + halfSize, z + halfSize,
                    x + halfSize, y + halfSize, z + halfSize,
                    x + halfSize, y + halfSize, z - halfSize,
                    x - halfSize, y + halfSize, z - halfSize,
                    
                    // Bottom face
                    x - halfSize, y - halfSize, z - halfSize,
                    x + halfSize, y - halfSize, z - halfSize,
                    x + halfSize, y - halfSize, z + halfSize,
                    x + halfSize, y - halfSize, z + halfSize,
                    x - halfSize, y - halfSize, z + halfSize,
                    x - halfSize, y - halfSize, z - halfSize,
                    
                    // Right face
                    x + halfSize, y - halfSize, z - halfSize,
                    x + halfSize, y + halfSize, z - halfSize,
                    x + halfSize, y + halfSize, z + halfSize,
                    x + halfSize, y + halfSize, z + halfSize,
                    x + halfSize, y - halfSize, z + halfSize,
                    x + halfSize, y - halfSize, z - halfSize,
                    
                    // Left face
                    x - halfSize, y - halfSize, z - halfSize,
                    x - halfSize, y - halfSize, z + halfSize,
                    x - halfSize, y + halfSize, z + halfSize,
                    x - halfSize, y + halfSize, z + halfSize,
                    x - halfSize, y + halfSize, z - halfSize,
                    x - halfSize, y - halfSize, z - halfSize
                ];
                
                positions.push(...vertices);
                
                // Add colors for all vertices
                for (let i = 0; i < 36; i++) {
                    colors.push(...color);
                }
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                // Update FPS counter
                this.frameCount++;
                const currentTime = performance.now();
                if (currentTime > this.lastTime + 1000) {
                    this.fps = Math.round((this.frameCount * 1000) / (currentTime - this.lastTime));
                    document.getElementById('fps-counter').textContent = this.fps;
                    this.frameCount = 0;
                    this.lastTime = currentTime;
                }
                
                this.renderer.render(this.scene, this.camera);
            }
        }
        
        // Initialize the visualizer when the page loads
        window.addEventListener('load', () => {
            new ROS3DVisualizer();
        });
    </script>
</body>
</html>
